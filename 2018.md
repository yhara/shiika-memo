## 2018/03/09

### Singleton

- String is an instance of Class
- String's superclass is Object
- Array is an intance of Class
- Array's superclass template is `Object`
- Array[Int] is an instance of Class
- Array[Int]'s superclass is Object
- If one defined SortedArray[T] < Array[T]:
  - SortedArray is an intance of Class
  - SortedArray[T]'s superclass template is `Array[T]`
  - SortedArray[Int] is an instance of Class
  - SortedArray[Int]'s superclass is Array[Int]
- Class is an instance of Class
- Class's superclass is Module
- Module is an instance of Class
- Module's superclass is Object
- Object is an instance of Class
- Object's superclass is nil

### Metaclass vs. singleton methods

Maybe Metaclass model is too complex... :thinking:
How about singleton methods?

- Allow classes to have singleton methods
  - (Unlike Ruby, singleton methods are allowed only to Classes and Modules)
- `String.new() -> String` is a singleton method of `String`
- `String` itself is an instance of `Class` class
  - There are many instances of `Class` class but their `.new` method
    have all different signature
  - This is legal because they are singleton method

So next question is how to mix this with generics.

- `Array.new` is not allowed
- `Array[Int].new(100)` should be legal
  - So specialized class `Array[Int]` has a singleton method `new(Int) -> Array[Int]`
- `Array` does not have `.new` but has some other methods
  - Like `Array.constants`?
  - This method is defined in `Class` (or inherited from the superclass `Module`)
    - Remember `Array` is an instance of `Class`
    - (Memo: `Class` is also an instance of `Class`)

### Metaclass

- `"foo".reverse`
  - String#reverse() -> String
- `"foo".object_id`
  - Object#object_id() -> Int
- `String.new`
  - Meta:String#new() -> String

- `[1,2,3].reverse`
  - Array[Int]#reverse() -> Array[Int]
- `Array[Int].new(1,2,3)`
  - Meta:Array[Int]#new(*items) -> Array[Int]

### Metaclasses in Smalltalk

(I'm not sure this is correct)

- Everything is object
- So class itself is an object
- For each class `X`, there is a metaclass `X class`
  - Metaclass is also an object (instance of `Metaclass`)
    - `Metaclass` is also an object (instance of `Metaclass` itself, so there is no things like meta-meta-class)

## 2018/03/08

### Meta:Pair

:thinking:

```
 Object     Meta:Object  "Object"      Object    GenericClass   Meta:Object
 .object_id  .new                                    .[]
   v           v            v             v           v             v
  Int        Meta:Int   Pair[S,T]   Pair[Int,Int] Meta:Pair  Meta:Pair[Int,Int]
```

### Current status

Exception: 

> Shiika::Program::SkTypeError:
>   class `Meta:Pair' does not have a method `[]'

Shiika source:

      Pair[Int, Bool].new(1, true).fst

`Pair[Int, Bool]` is parsed as `Pair.[](Int, Bool)` here.
So generic class `Pair` should have a class method `[]`.

## 2018/03/04

### Container classes in Ruby

- Array[T]
- Hash[K, V]
- Set[T]  (stdlib)

and Enumerable?

## 2018/03/02

### What to do next

      class Pair[S, T]
        # Here we refer to `S`, but env.find_type raises "unknown type: S"
        def initialize(@a: S, @b: T)
        end

        def fst -> S; @a; end
        def snd -> T; @b; end
      end
      Pair[Int, Bool].new(1, true).fst

- `env.find_type('S')` should return something
  - Like `Type::Typaram`?
    - Currently it is almost the same as `Object`
    - This object will have the information about upper/lower bound, if introduced
      - to tell if a class confirms to the type

## 2018/03/01

### Keyword argument

(Current idea) All methods can be invoked with keyword arguments.

```
def foo(a: Int = 1, b: Int = 2); end

foo(3, 4)
foo(3, b: 4)     # Allow this?
foo(b: 4, a: 3)
```

## 2018/02/28

### Types in Shiika

:thinking:

- Value types
  - Concrete value types
    - Class type
  - Abstract value types
    - Type parameter
- Non-value types
  - Generic class
  - Method signature
  - Function signature?

## 2018/02/27

### Types in Scala

https://www.scala-lang.org/files/archive/spec/2.11/03-types.html#paths

- Value types
  - Concrete value types
    - Class type
    - Compound type
  - Abstract value types
    - Type parameter
    - Abstract type binding
- Non-value types
  - Type constructor
  - Method type

## 2018/02/25

### Scala functions

- `Int => Int` is just a [shorthand](https://www.scala-lang.org/files/archive/spec/2.11/03-types.html#function-types) of `Function1[Int, Int]`
- This type does not include all information about the function (eg. default value for a parameter)
- IOW this type includes all the information for type checking
  - Arity
  - Types of each paraemter
  - Type of the return value

## 2018/02/24

### Signature of closures?

```
f = fn(x){ x + 1 }
```

What is "type" and/or "signature" of f?

## 2018/02/23

### Type vs. Signature

- What is "signature"?
  - Is it a type or not?
- eg. In Haskell:
  - Every value belongs to a type
  - Functions are values
  - So each function belongs to a type such as `f :: Int -> Int`
  - Application `f "foo"` is a type error
- In Shiika, methods are not first-class value
  - But off course, we want to check type errors for method calls
  - There should be information of what a method takes and returns (= Signature)

## 2018/02/20

### Funcion call or variable reference

```rb
  def do_task(after: () -> Void)
    # do something

    # This may look like a function call, but...
    after

    # There's a case that passing `after` to another function,
    # so `after` should be a variable reference.
    do_task_2(after)

    # Allow this?
    after()

    # How about these?
    another()  # Call of another method
    another    # Allow this or prohibit this?
  end

  def another
  end
```

## 2018/02/19

### Nullary-function problem

- Ruby's `Proc` is like function but has different syntax to invoke

```rb
def foo(*args); end
bar = Proc.new

foo  # Method call
bar  # Variable reference
foo(1)  # Method call
bar(1)  # *Error*
bar.call(1)  # OK

bar[1]       # Alternative syntax of call (`#[]` is an alias of `#call`)
bar.(1)      # Alternative syntax of call (rarely used, though)
```

Note that you need to write `bar.call` to invoke the function with 0 arguments.

## 2018/02/18

### Function type?

- Swift has function as first-class value
  - But there is no class for function?
  - https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/swift/grammar/function-type
  - Functions and tuples look like special in Swift
- Scala has function as first-class value
  - They are instances of `Function0` ã€œ `Function22`
  - With syntax sugar `f(x)` = `f.apply(x)`
  - Method, on the other hand, is not a first-class value
- Ruby has no "function"
  - But has `Proc` class instead
  - Ruby also has `Method` class (not so popular as `Proc`)

## 2018/02/17

### Data structure for types

- What object should `env.find_type` return?
  - It should be able to tell an object conforms (= its class conforms) to the type

### Type syntax

- Types can be appeared in some place of a program
  - Function signature (params, return value)
  - Instance variable type
  - Cast
- Type syntax
  - Class name (non-generic)
    - => An instance of the class or its subclasses
  - Class name (generic)
    - => Illegal (type argument required)
  - Generic class name + type arguments
    - eg. `Stack[Int]`
    - => Instance of the class
    - (This will change once covariance/contravariance are introduced)
  - Type parameter name
    - => An instance of the class Object or its subclasses
    - (Once upper/lower bounds are introduced, instance of a class between the bound)

## 2018/02/16

### What is type

- Given `x: Foo`, x is an instance of Foo or its subclasses
  - Type = set of classes
- `x: Array` is not allowed (missing type argument)
  - Shiika needs a definition of type syntax

### Is `Stack[Int]` a class?

No?

### Generics

Thinking about generics since the new year. Shiika won't have even the class Array without it.

Notes:

- Use `[]` for generics syntax
- Reason1: `<>` is not suitable when `<:` and `>:` are introduced to denote upper/lower bound
  - Swift uses `:` to denote upper bound (No syntax for lower bound)
- Reason2: `Stack[T]` looks like a method call :-)
  - Can we define this as method call?
  - `Stack#[]` to return specialized class

## 2018/02/15

### MetaClass

- In Ruby, `Array` evaluates to an object (an instance of the `Class` class)
- In Shiika too?
- But `Array.new` and `String.new` have different signature
  - In Ruby, `new` is their "singleton method" so they can behave
    differently even the name is the same
- No plan to introduce "singleton method" to Shiika
- MetaClass
  - `Array` evaluates to an object
  - Its class is `Meta:Array` (metaclass of Array)
  - `new` is defined on `Meta:Array`

### Shiika

- Static typing
- Ruby-like syntax
  - But not 100% compatible
- Interpreter is written in Ruby (for now)
  - Future plan: compile to LLVM IR (using Go or something?)
- Challenge
  - Rubyish + Static type system

### shiika-memo

Notes for https://github.com/yhara/shiika .
